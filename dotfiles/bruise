#!/usr/bin/env bash

# tabstop: 4

_VENV_BASE=$HOME/.venvs

## get the name of the branch, within the following revision control systems
function __fetch_repo_details() {

    __OLD_TOP=$__TOPLEVEL
    __OLD_BRANCH=$BRANCHNAME

    # If we're not in a git repo clean up and exit
    BRANCHNAME=`git branch 2> /dev/null | grep -e ^* | sed -E  s/^\\\\\*\ \(.+\)$/\\\\\1/`
    if [ -z $BRANCHNAME ]; then
        cleanup_bruise
        return 1
    else
        __TOPLEVEL=`git rev-parse --show-toplevel`
        REPONAME=`basename "$__TOPLEVEL"`
        REQTXT=$__TOPLEVEL/requirements.txt
    fi

    # If we're not in a python repo clean up and exit
    if [ ! -f $REQTXT ]; then
        cleanup_bruise
        return 1
    fi

    # If we're in the same repo / branch don't do anything
    if [ "$__OLD_TOP" = "$__TOPLEVEL" ] && [ "$__OLD_BRANCH" = "$BRANCHNAME" ]; then
        return 1
    fi

    if [ ! -d $_VENV_BASE ]; then
        mkdir -p $_VENV_BASE
    fi

    # pyenv users get an environment prefixed with python version
    if [ -f $__TOPLEVEL/.python-version ]; then
        PYTHON_VERSION=`cat $__TOPLEVEL/.python-version`
        VENV_NAME=$PYTHON_VERSION.$REPONAME.$BRANCHNAME
    else
        VENV_NAME=$REPONAME.$BRANCHNAME
    fi
    VENV_PATH=$_VENV_BASE/$VENV_NAME
}

function cleanup_bruise() {
    unset BRUISE_DIR
    unset PYTHON_VERSION
    unset REPONAME
    unset REQTXT
    unset VENV_NAME
    unset VENV_PATH
    unset VENV_PREFIX
    unset __OLD_BRANCH
    unset __OLD_TOP
    unset __TOPLEVEL
    deactivate &> /dev/null
    return 0
}

# create the pythonbrew venv combination
# if there's a requirements.txt we'll pip that puppy
function bruisemake() {

    if [ ! -z $1 ]; then
        VENV_PATH=$_VENV_BASE/$1
    fi

    if [ ! -d $VENV_PATH ]; then
        virtualenv --no-site-packages $VENV_PATH
    fi
    source $VENV_PATH/bin/activate
    pip install -r $REQTXT

}

function __bruise() {

    # pyenv support or not ;)
    if [ -z $PYTHON_VERSION ]; then
        VENV_PREFIX="${PYTHON_VERSION}"
    else
        VENV_PREFIX="${PYTHON_VERSION}."
    fi

    # if for some reason we're testing in a local venv, it wins
    if [ -d $__TOPLEVEL/venv ]; then
       BRUISE_DIR=$__TOPLEVEL/venv
    else
       bruisebase="${_VENV_BASE}/${VENV_PREFIX}${REPONAME}"
       if [ -d ${bruisebase}.${BRANCHNAME} ]; then
         BRUISE_DIR=${bruisebase}.${BRANCHNAME}
       elif [ -d ${bruisebase}.master ]; then
         BRUISE_DIR=${bruisebase}.master
       elif [ -d ${bruisebase} ]; then
         BRUISE_DIR=${bruisebase}
       fi
    fi

    if [ -f $__TOPLEVEL/.python-version ]; then
      if [ $? -ne 0 ]; then
          echo "Looks like you need pyenv to install your version, I'll go do that now."
          pyenv install `cat $__TOPLEVEL/.python-version`
          pyenv rehash
          pip install virtualenv
          cd .
      fi
    fi

    if [ -z $BRUISE_DIR ]; then
        echo "No environment exists, try running bruisemake"
        echo ""
        return 1
    fi

    source ${BRUISE_DIR}/bin/activate

    # todo, compare modified times on requirements.txt and the $VENV_PATH
    if [ $REQTXT -nt $BRUISE_DIR ]; then
        pip install -r $REQTXT
    fi
}

function bruiselist() {
    ls -1 $_VENV_BASE
}

function bruiseuse() {
    if [ -z $1 ]; then
      __bruise
    else
        source $_VENV_BASE/$1/bin/activate
    fi
}

function bruisedelete() {

    if [ -z $1 ]; then
        echo "bruisedelete bruise_to_delete"
        return 1
    fi

    for i in `ls $_VENV_BASE`; do
        if [ "X$i" == "X$1" ]; then
            rm -rf $_VENV_BASE/$i
        fi
    done

}

cd() {
    builtin cd "$@"
    __fetch_repo_details
    if [ $? -eq "0" ]; then
        __bruise
    fi
    return 0
}
