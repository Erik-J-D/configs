#!/usr/bin/env bash

# tabstop: 4

_VENV_BASE=$HOME/.venvs

## get the name of the branch, within the following revision control systems
function __fetch_repo_details() {

    BRANCHNAME=`git branch 2> /dev/null | grep -e ^* | sed -E  s/^\\\\\*\ \(.+\)$/\\\\\1\ /`
    if [ -z $BRANCHNAME ]; then
        unset VENV_NAME
        unset VENV_PATH
        unset VENV_PREFIX
        unset REPONAME
        return
    else
        __TOPLEVEL=`git rev-parse --show-toplevel`
        REPONAME=`basename "$__TOPLEVEL"`
    fi

    if [ ! -d $_VENV_BASE ]; then
        mkdir -p $_VENV_BASE
    fi

    # pyenv users get an environment prefixed with python version
    if [ -f $__TOPLEVEL/.python-version ]; then
        PYTHON_VERSION=`cat $__TOPLEVEL/.python-version`
        VENV_NAME=$PYTHON_VERSION.$REPONAME.$BRANCHNAME
    else
        VENV_NAME=$REPONAME.$BRANCHNAME
    fi
    VENV_PATH=$_VENV_BASE/$VENV_NAME

}

# create the pythonbrew venv combination
# if there's a requirements.txt we'll pip that puppy
function bruisemake() {

    if [ ! -z $1 ]; then
        VENV_PATH=$_VENV_BASE/$1
    fi

    if [ ! -d $VENV_PATH ]; then
        virtualenv --no-site-packages $VENV_PATH
    fi
    source $VENV_PATH/bin/activate
    pip install -r $__TOPLEVEL/requirements.txt

}

function __bruise() {

    # pyenv support or not ;)
    if [ -z $PYTHON_VERSION ]; then
        VENV_PREFIX="${PYTHON_VERSION}"
    else
        VENV_PREFIX="${PYTHON_VERSION}."
    fi

    # if for some reason we're testing in a local venv, it wins
    if [ -d `pwd`/venv ]; then
       BRUISE_DIR=`pwd`/venv
    else
       bruisebase="${_VENV_BASE}/${VENV_PREFIX}${REPONAME}"
       if [ -d ${bruisebase}.${BRANCHNAME} ]; then
         BRUISE_DIR=${bruisebase}.${BRANCHNAME}
       elif [ -d ${bruisebase}.master ]; then
         BRUISE_DIR=${bruisebase}.master
       elif [ -d ${bruisebase} ]; then
         BRUISE_DIR=${bruisebase}
       fi
    fi

    if [ -f $__TOPLEVEL/.python-version ]; then
      pyenv versions|grep `cat $__TOPLEVEL/.python-version`
      if [ $? -ne 0 ]; then
          echo "Looks like you need pyenv to install your version, I'll go do that now."
          pyenv install `cat $__TOPLEVEL/.python-version`
          pyenv rehash
          pip install virtualenv
          cd .
      fi
    fi

    if [ -z $BRUISE_DIR ]; then
        echo "No environment exists, try running bruisemake"
        return 1
    fi

    echo "Environment loaded from ${BRUISE_DIR}"
    source ${BRUISE_DIR}/bin/activate

    # todo, compare modified times on requirements.txt and the $VENV_PATH
    if [ $__TOPLEVEL/requirements.txt -nt $BRUISE_DIR ]; then
        pip install -r $__TOPLEVEL/requirements.txt
    fi
}

function bruiselist() {
    ls -1 $_VENV_BASE
}

function bruiseuse() {
    if [ -z $1 ]; then
      __bruise
    else
        source $_VENV_BASE/$1/bin/activate
    fi
}

function bruisedelete() {

    if [ -z $1 ]; then
        echo "bruisedelete bruise_to_delete"
        return 1
    fi

    for i in `ls $_VENV_BASE`; do
        envs=`ls $_VENV_BASE/$i`
        for e in $envs; do
            if [ "X$e" == "X$1" ]; then
                rm -rf $_VENV_BASE/$i/$e
            fi
        done
    done

}

cd() {
    builtin cd "$@"
    __fetch_repo_details
    if [ ! -z $BRANCHNAME ]; then
        __bruise
    fi
}
